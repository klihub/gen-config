#!/usr/bin/env python3

import ipaddress
from genconfig.parser import *

class IPTables:
    BUILTIN_CHAINS = {
        'filter': [ 'INPUT', 'FORWARD', 'OUTPUT'],
        'nat':    [ 'PREROUTING', 'INPUT', 'OUTPUT', 'POSTROUTING' ],
        'mangle': [ 'PREROUTING', 'INPUT', 'FORWARD', 'OUTPUT', 'POSTROUTING' ],
        'raw':    [ 'PREROUTING', 'OUTPUT' ],
    }
    CONFIG_FILES = {
        'restore':  '/etc/sysconfig/iptables',
        'iptables': '/etc/sysconfig/iptables-commands'
    }

    class Table:
        def __init__(self, name, chains = []):
            self.name = name
            self.chains = []
            self.chain_index = {}

            for c in chains:
                if type(c) == type(''):
                    self.chains.append(IPTables.Chain(c))
                else:
                    self.chains.append(IPTables.Chain(c[0], c[1]))

            if self.name in IPTables.BUILTIN_CHAINS.keys():
                builtin = IPTables.BUILTIN_CHAINS[self.name]
                for c in builtin:
                    if c not in [x.name for x in self.chains]:
                        self.chains.append(IPTables.Chain(c))

            self.chain_index = {}
            for idx in range(0, len(self.chains)):
                self.chain_index[self.chains[idx].name] = idx

        def chain(self, name, policy = None):
            if name not in [x.name for x in self.chains]:
                c = IPTables.Chain(name, policy)
                self.chains.append(c)
                self.chain_index[name] = len(self.chains) - 1
            else:
                c = self.chains[self.chain_index[name]]
                if policy and c.policy and policy != c.policy:
                    raise RuntimeError('chain %s has conflicting policies' %
                                       (c.name, c.policy, policy))
            return c

        def write_restore(self, f):
            f.write('# %s configuration generated by %s' %
                    (self.name, __file__))
            f.write('*%s' % self.name)
            for c in self.chains:
                f.write(':%s %s [0:0]' % (c.name, c.policy))
            for c in self.chains:
                for r in c.rules:
                    f.write('%s' % r)

        def write_commands(self, f):
            f.write('# %s commands generated by %s' %
                    (self.name, __file__))
            for c in self.chains:
                if c.name not in IPTables.BUILTIN_CHAINS[self.name]:
                    f.write('iptables -t %s -N %s' % (self.name, c.name))
                if c.policy != 'ACCEPT':
                    f.write('iptables -t %s -P %s %s' %
                            (self.name, c.name, c.policy))
            for c in self.chains:
                for r in c.rules:
                    f.write('iptables -t %s -A %s %s' % (self.name, c.name, r))

    class Marker:
        def __init__(self, name):
            self.name = name

    class Chain:
        def __init__(self, name, policy = None):
            self.name = name
            self.policy = policy if policy is not None else 'ACCEPT'
            self.rules = []

        def marker(self, name, index = -1):
            if index > -1:
                self.rules.insert(index, Marker(name))
            else:
                self.rules.append(Marker(name))

        def marker_index(self, name):
            for idx in range(0, len(self.rules)):
                if type(self.rules[idx]) == Marker:
                    return idx
            return -1

        def insert(self, rule, after_mark = None, before_mark = None, index = 0):
            if after_mark and before_mark:
                raise RuntimeError('both before and after marker given')
            if after_mark:
                idx = self.marker_index(after_mark)
                idx += 1 + index
            elif before_mark:
                idx = self.marker_index(before_mark)
                idx -= index
            self.rules(insert, idx, rule)

        def append(self, rule, before_mark = None):
            if before_mark:
                idx = self.marker_index(before_mark)
            else:
                idx = len(self.rules)
            self.rules.insert(idx, rule)

    def __init__(self, policy = None):
        self.filter = IPTables.Table('filter',
                                     [('INPUT', policy or 'DROP'),
                                      ('FORWARD', policy or 'DROP'),
                                      'OUTPUT'])
        self.nat = IPTables.Table('nat')
        self.mangle = IPTables.Table('mangle')
        self.raw = IPTables.Table('raw')
        self.tables = {
            'filter': self.filter,
            'nat': self.nat,
            'mangle': self.mangle,
            'raw': self.raw
        }

    def set_policy(self, chain, policy):
        c = self.chains[self.chain_index[chain]]
        c.policy = policy

    def table(self, name):
        return self.tables[name]

    def chain(self, table, name):
        return self.table(table).chain(name)

    def write(self, fs, syntax = 'iptables', paths = None):
        if not paths:
            paths = IPTables.CONFIG_FILES
        f = fs.open(IPTables.CONFIG_FILES[syntax])
        if syntax == 'restore':
            for t in self.tables.values():
                t.write_restore(f)
            f.write('COMMIT')
        else:
            for t in self.tables.values():
                t.write_commands(f)
        f.close()

class Firewall(Node):
    def __init__(self, nodedef, root, parent, node_tkn):
        Node.__init__(self, nodedef, root, parent, node_tkn)
        self.node_tkn = node_tkn
        self.protected = []
        self.isolated = []
        self.trusted_interfaces = []
        self.trusted_networks = []
        self.trusted_hosts = []
        self.snats = []

    def parse_protect(self, kw_protect, *tokens):
        self.process_list(tokens, self.collect_device, self.protected)

    def parse_isolate(self, kw_isolate, *tokens):
        devices = []
        self.process_list(tokens, self.collect_device, devices)
        self.isolated.append(devices)

    def collect_device(self, device, devices):
        devices.append(device.str)

    def parse_trusted(self, kw_trusted, kw_kind, *token):
        if kw_kind.str == 'host':
            self.trusted_hosts.append(ipaddress.ip_address(token[0].str))
        elif kw_kind.str == 'network' or kw_kind.str == 'net':
            self.trusted_networks.append(ipaddress.ip_interface(token[0].str))
        else:
            if not token:
                if self.parent.nodedef.name != 'interface':
                    raise RuntimeError('implicit trusted interface must be ' +
                                       'nested under an interface')
                else:
                    name = self.parent.name
            else:
                name = token[0].str
            self.trusted_interfaces.append(name)

    def parse_accept(self, kw_accept, *tokens):
        pass

    def parse_snat(self, kw_snat, *tokens):
        self.process_list(tokens, self.collect_snat, self.snats)

    def collect_snat(self, snat, snats):
        snats.append(snat.str)

    def finalize(self):
        Node.finalize(self)

    def dump(self):
        print('firewall')

def generate_firewall(nodedef, nodes, fs):
    print('generate_firewall...')

    ipt = IPTables()

    # allow conntrack-kosher traffic
    c = ipt.chain('filter', 'FORWARD')
    c.append('-m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT')

    # allow traffic from trusted interfaces, networks, and hosts
    c.append('-j CHECK-TRUSTED')
    for fw in nodes:
        if fw.trusted_interfaces or fw.trusted_networks or fw.trusted_hosts:
            c = ipt.chain('filter', 'CHECK-TRUSTED')
            for i in fw.trusted_interfaces:
                c.append('-i %s -j ACCEPT' % i)
            for n in fw.trusted_networks:
                c.append('-s %s -j ACCEPT' % n.with_prefixlen)
            for h in fw.trusted_hosts:
                c.append('-s %s -j ACCEPT' % str(h))

    # take care of interface isolation
    c = ipt.chain('filter', 'FORWARD')
    c.append('-j ISOLATE')
    c = ipt.chain('filter', 'ISOLATE')

    for devices in fw.isolated:
        if len(devices) > 1:
            for src in devices:
                for dst in devices:
                    c.append('-i %s -o %s -j DROP' % (src, dst))
        else:
            src = dst = devices[0]
            c.append('-i %s -o %s -j DROP' % (src, dst))

    # take care of SNAT/MASQUERADING
    c = ipt.chain('nat', 'POSTROUTING')
    uplinks = []
    print('snats: %s' % str(fw.snats))
    for i in Parser.nodes['interface'].nodes:
        if i.uplink:
            uplinks.append(i)
            if i.name not in fw.snats:
                fw.snats.append(i.name)
        if i.name in fw.snats:
            if i.addresses == 'dhcp':
                c.append('-o %s -j MASQUERADE' % i.name)
            else:
                c.append('-o %s -j SNAT --to %s' % str(i.addresses[0].ip))

    # take care of DNATs
    pre = ipt.chain('nat', 'PREROUTING')
    out = ipt.chain('nat', 'OUTPUT')
    for d in fw.children:
        if d.nodedef.name != 'dnat':
            continue
        if d.ifout:
            out.append(d.generate())
        else:
            pre.append(d.generate())

    # accept DNS traffic if necessary

    # take care of any other accept rules

    # write out ruleset
    ipt.write(fs)


class Dnat(Node):
    def __init__(self, nodedef, root, parent, node_tkn):
        Node.__init__(self, nodedef, root, parent, node_tkn)
        self.node_tkn = node_tkn
        self.ifin = None
        self.ifout = None
        self.proto = None
        self.src_addr = self.src_port = None
        self.dst_addr = self.dst_port = None
        self.to = None

    def parse_in(self, kw_in, token):
        self.ifin = token.str
        if self.ifout:
            raise RuntimeError('%s:%s: DNAT with both in and out interfaces' %
                               self.where())

    def parse_out(self, kw_out, token):
        self.ifout = token.str
        if self.ifin:
            raise RuntimeError('%s:%s: DNAT with both in and out interfaces' %
                               self.where())

    def parse_proto(self, token):
        self.proto = token.str

    def parse_src(self, kw_src, token):
        src = token.str
        if src.startswith(':'):
            self.src_port = src[1:]
        elif ':' in src:
            self.src_addr, self.src_port = src.split(':')
        else:
            self.src_addr = src

    def parse_dst(self, kw_dst, token):
        dst = token.str
        if dst.startswith(':'):
            self.dst_port = dst[1:]
        elif ':' in dst:
            self.dst_addr, self.dst_port = dst.split(':')
        else:
            self.dst_addr = dst

    def parse_to(self, kw_to, token):
        self.to = token.str

    def append(self, str, option, arg):
        t = ' ' if str else ''
        if arg:
            str += '%s%s %s' % (t, option, arg)
        return str

    def restore(self, str):
        t = ' ' if self.restore else ''
        self.restore += '%s%s' % (t, str)

    def generate(self):
        str = ''
        str = self.append(str, '-i', self.ifin)
        str = self.append(str, '-o', self.ifout)
        str = self.append(str, '-p', self.proto)
        str = self.append(str, '-s', self.src_addr)
        str = self.append(str, '--sport', self.src_port)
        str = self.append(str, '-d', self.dst_addr)
        str = self.append(str, '--dport', self.dst_port)
        str = self.append(str, '-j DNAT --to-destination', self.to)
        return str


class Match(Node):
    def __init__(self, nodedef, root, parent, node_tkn, module):
        Node.__init__(self, nodedef, root, parent, node_tkn)
        self.module = module
        self.args = []
        print('match %s' % self.module.str)

    def add_option(self, tkn_option, tkn_arg):
        print('match %s option %s %s' %
              (self.module.str, tkn_option.str, tkn_arg.str))
        self.args.append(tkn_option)
        self.args.append(tkn_arg)

    def generate(self):
        return '--match %s' + ' '.join([x.str for x in self.args])


NodeDef(
    'firewall', Firewall, 0,
    Lexer.Keywords(['protect', 'accept', 'drop', 'reject',
                    'trusted', 'host', 'interface', 'net', 'network',
                    'snat', 'input', 'output', 'forward',
                    'isolate']),
    Lexer.NoTokens(),
    [Parser.Rule('_protect_ _token_(, _token_)*' , 'parse_protect'),
     Parser.Rule('_isolate_ _token_(, _token_)*' , 'parse_isolate'),
     Parser.Rule('_trusted_ (_interface_|_network_|_host_) _token_',
                 'parse_trusted'),
     Parser.Rule('_trusted_ (_interface_)'       , 'parse_trusted'),
     Parser.Rule('_snat_ _token_(, _token_)*'    , 'parse_snat'   ),
     Parser.Rule('_accept_ _token_( _token_)*'   , 'parse_accept' )],
    generate_firewall
)


NodeDef('dnat', Dnat, 0,
        Lexer.Keywords(['in', 'out', 'tcp', 'udp', 'src', 'dst', 'to']),
        Lexer.NoTokens(),
        [Parser.Rule('_in_ _token_' , 'parse_in'   ),
         Parser.Rule('_out_ _token_', 'parse_out'  ),
         Parser.Rule('_tcp_|_udp_'  , 'parse_proto'),
         Parser.Rule('_src_ _token_', 'parse_src'  ),
         Parser.Rule('_dst_ _token_', 'parse_dst'  ),
         Parser.Rule('_to_ _token_' , 'parse_to'   )])

NodeDef('match', Match, 1,
        Lexer.NoKeywords(),
        [Lexer.TokenRegex(r'(-.*)', 'option')],
        [Parser.Rule('_option_ _token_', 'add_option')])
